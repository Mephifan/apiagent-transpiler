/**
 * Autogenerated file
 * Create time 2018-12-21 12:27:05.933387 +0100 CET m=+0.003775259
 * Copyright (c) 2019 Adcubum AG
 *
 */

import {PolymerElement} from '@polymer/polymer/polymer-element.js';
import {ApiService} from '/apiService.js'

/**
 * `TagService`
 */

/**
 * Interface Definitonen für die Entity Tags 
Verwaltet Tags
 */

/**
 * package: tags
 * version: 1
 */

/**
 * ```
 * `Tag`
 * 
 * - id ulid 
 * - label string 
 * - brailleLabel string `TagEntityResponse`
 * 
 * - item Tag 
 * - links Link `TagCollectionResponse`
 * 
 * - data TagEntityResponse 
 * - links Link 
 *
 * ```
 *
 * @customElement
 * @polymer
 * @extends PolymerElement
 * @appliesMixin ApiService
 * @demo demo/index.html
 */
class TagServiceEntity extends ApiService(PolymerElement) {

    static get properties() {
        return {
            /**
             * Exposed attributes
             * Which properties should be exposed?
             */

            /**
             * rawEntity includes all data from the response
             * data, links, ...
             */
            rawEntity: {
                type: Object,
                notify: true,
            },
            /**
             * Model from protocolBuffer definition 'Body'
             */
            entity: {
                type: Object,
                value: () => {
                    return { 
                        /**
                        * für IDs werden wir intern ulid verwenden
                        */
                        id: '',
                        /**
                        * Taglabel wird als Standardrepräsentation verwendet.
                        */
                        label: '',
                        /**
                        * Taglabel in der Braille-Schreibweise
                        */
                        brailleLabel: '',
                    }
                },
                notify: true,
            },
            /**
             * Property-Meta informationen
             * extended meta information about the entity
             */
            meta: {
                type: Object,
                value: () => {
                    return { 
                        /**
                        * für IDs werden wir intern ulid verwenden
                        */
                        id: {
                            description: 'für IDs werden wir intern ulid verwenden',
                            type: 'string',
                            mandatory: false,
                        },
                        /**
                        * Taglabel wird als Standardrepräsentation verwendet.
                        */
                        label: {
                            description: 'Taglabel wird als Standardrepräsentation verwendet.',
                            type: 'string',
                            mandatory: true,
                        },
                        /**
                        * Taglabel in der Braille-Schreibweise
                        */
                        brailleLabel: {
                            description: 'Taglabel in der Braille-Schreibweise',
                            type: 'string',
                            mandatory: false,
                        },
                    }
                },
                notify: true,
            },
            /**
             * Hypermedia As The Engine Of Application State (HATEOAS)
             * Array of HATEOAS links
             */
            hateoas: {
                type: Array,
            },

        };
    }


    /**
     *  ```
     *  rpc CreateTag (Tag) returns (TagEntityResponse) {
     *      option (google.api.http) = {
     *          post: "/v1/tags"
     *          body: "item"
     *      };
     *  }
     *  ```
     *  Erstellt einen neuen Tag
     * @public
     */
    createTag() {
        
        
        const createRequest = new Request('/v1/tags', {
            method: 'POST',
            headers: {},
            body: JSON.stringify(this.entity)
        });
        this.fieldErrors = this._validateFields();
        if (!this.fieldErrors.error.length){
            this.generateRequest(createRequest);
        }
        
    }

    /**
     *  ```
     *  rpc GetTag (Tag) returns (TagEntityResponse) {
     *      option (google.api.http) = {
     *          get: "/v1/tags/{id}"
     *      };
     *  }
     *  ```
     *  Abfragen eines Tags
     * @public
     */
    getTag() {
        
        
        const createRequest = new Request('/v1/tags/'+this.entity.id, {
            method: 'GET',
            headers: {}
        });
        this.generateRequest(createRequest);

        
    }

    /**
     *  ```
     *  rpc DeleteTag (Tag) returns (TagEntityResponse) {
     *      option (google.api.http) = {
     *          delete: "/v1/tags/{id}"
     *      };
     *  }
     *  ```
     *  Löschen eines Tags
     * @public
     */
    deleteTag() {
        
        
        const createRequest = new Request('/v1/tags/'+this.entity.id, {
            method: 'DELETE',
            headers: {}
        });
        this.generateRequest(createRequest);

        
    }

    /**
     *  ```
     *  rpc UpdateTag (Tag) returns (TagEntityResponse) {
     *      option (google.api.http) = {
     *          put: "/tags/{id}"
     *          body: "item"
     *      };
     *  }
     *  ```
     *  Aktualisert einen Tag
     * @public
     */
    updateTag() {
        
        
        const createRequest = new Request('/tags/'+this.entity.id, {
            method: 'PUT',
            headers: {},
            body: JSON.stringify(this.entity)
        });
        this.fieldErrors = this._validateFields();
        if (!this.fieldErrors.error.length){
            this.generateRequest(createRequest);
        }
        
    }

    /**
     *  ```
     *  rpc doSomething (CustomParams) returns (TagEntityResponse) {
     *      option (google.api.http) = {
     *          put: "/tags/{id}:doSomething"
     *      };
     *  }
     *  ```
     *  Irgendeine Custom Function mit KeyValue Params
     * @public
     */
    doSomething() {
        
        
        const createRequest = new Request('/tags/'+this.entity.id+':doSomething', {
            method: 'PUT',
            headers: {}
        });
        this.generateRequest(createRequest);

        
    }


    /**
     * Inject von einer raw Entity. Normalerweise ein Item aus einer Collection.
     * Ein Inject erstellt eine komplette Entität für die weitere Verwendung.
     * Das Verhalten ist analog wie nach einem get...
     *
     * @event inject-completed(payload: entity Model)
     * @param rawEntity
     * @public
     */
    inject(rawEntity) {

        this._processResponse(rawEntity);
    }

    /**
     * Traversiert durch alle Felder der Entity
     * und ruft die interne Funktion '_validateField(fieldId)' auf.
     * @return fieldError{}
     * @private
     */
    _validateFields(){
        for (let f in this.entity){
            if (this.entity.hasOwnProperty(f)) {
                this.fieldErrors = this._validateField(f);
            }
        }
        return this.fieldErrors;
    }

    /**
     * - Ruft pro Feld den Standardvalidator des apiService auf.
     * - Ruft - falls vorhanden - die dynamischen Validierungsfunktionen aus den Metainformationen auf.
     * @param fieldId
     * @return fieldError{}
     * @private
     */
    _validateField(fieldId) {
        this.fieldErrors = super._validateField(fieldId);
        console.log('entity validateField:', fieldId);

        // custom validation function from meta
        if (typeof this.meta[fieldId].validate === 'function'){
            this.fieldErrors = this.meta[fieldId].validate(this);
        }
        return this.fieldErrors;
    }

}

window.customElements.define('tag-service-entity', TagServiceEntity);




